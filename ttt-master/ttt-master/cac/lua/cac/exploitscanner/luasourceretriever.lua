local self = {}
CAC.LuaSourceRetriever = CAC.MakeConstructor (self)

function self:ctor ()
	self.LineCache = {}
end

function self:ClearCache ()
	self.LineCache = {}
end

function self:GetFileLines (sourcePath)
	if self.LineCache [sourcePath] == nil then
		local data = file.Read (sourcePath, "GAME")
		data = data or file.Read (sourcePath, "LUA")
		data = data or file.Read (sourcePath, SERVER and "LSV" or "LCL")
		
		if data then
			if string.find (data, "\n") then
				self.LineCache [sourcePath] = string.Split (data, "\n")
			else
				self.LineCache [sourcePath] = string.Split (data, "\r")
			end
		else
			self.LineCache [sourcePath] = false
		end
	end
	
	if self.LineCache [sourcePath] == false then return nil end
	
	return self.LineCache [sourcePath]
end

function self:GetFunctionSource (f, jitUtilFuncInfo, sourcePath)
	jitUtilFuncInfo = jitUtilFuncInfo or jit.util.funcinfo (f)
	sourcePath      = sourcePath      or string.gsub (jitUtilFuncInfo.source, "^@", "")
	
	local lines = self:GetFileLines (sourcePath)
	local code = nil
	
	if lines then
		local startLine = jitUtilFuncInfo.linedefined
		local endLine   = jitUtilFuncInfo.lastlinedefined
		
		if endLine <= #lines then
			local codeLines = {}
			for i = startLine, endLine do
				codeLines [#codeLines + 1] = lines [i]
			end
			code = table.concat (codeLines, "\n")
		end
	end
	
	if not code then
		local success, r0 = xpcall (
			function ()
				return CAC.Lua.BytecodeReader (f):ToString ()
			end,
			debug.traceback
		)
		
		if success then
			code = r0
		else
			code = "Failed to decompile:\n" .. r0 .. "\n" .. CAC.String.EscapeNonprintable (string.dump (f))
		end
	end
	
	return code
end

function self:__call ()
	return self.__ictor ()
end