local self = {}
CAC.LuaScanner = CAC.MakeConstructor (self)

function self:ctor (logger)
	self.Logger                   = logger or CAC.Logger
	
	self.Destroyed                = false
	
	self.LuaSnapshot              = nil
	self.LuaSignatureDatabase     = nil
	self.LuaScanResult            = nil
	
	self.LuaScannerStatus         = CAC.LuaScannerStatus ()
	
	CAC.EventProvider (self)
	
	if CAC.Settings:GetSettingsGroup ("LuaScannerSettings"):IsLuaScanningEnabled () then
		if CurTime () > 5 then
			self:Scan ()
		else
			timer.Simple (5,
				function ()
					if self.Destroyed then return end
					
					self:Scan ()
				end
			)
		end
	end
end

function self:dtor ()
	self.Destroyed = true
end

function self:GetLuaSnapshot ()
	return self.LuaSnapshot
end

function self:GetLuaSignatureDatabase ()
	return self.LuaSignatureDatabase
end

function self:GetLuaScanResult ()
	return self.LuaScanResult
end

function self:GetLuaScannerStatus ()
	return self.LuaScannerStatus
end

function self:Scan ()
	if self.LuaSnapshot then return end
	
	local t0 = SysTime ()
	self.LuaSnapshot = CAC.LuaSnapshot ()
	
	self.LuaScannerStatus:UpdateLastScanTime ()
	
	local serializerVersion = CAC.SerializerRegistry:GetLatestSerializerVersion ("LuaSnapshot")
	local serializer        = CAC.SerializerRegistry:GetSerializer ("LuaSnapshot", serializerVersion)
	
	local outBuffer = CAC.StringOutBuffer ()
	outBuffer:UInt32 (serializerVersion)
	serializer (self.LuaSnapshot, outBuffer)
	
	if CAC.IsDebug then
		print ("Snapshot took " .. CAC.FormatDuration (SysTime () - t0) .. ".")
		print ("Snapshot is " .. CAC.FormatFileSize (#outBuffer:GetString ()) .. ".")
	end
	
	local data = util.Base64Encode (outBuffer:GetString ())
	local blocks = {}
	
	local blockSize = 128 * 1024
	for i = 1, #data, blockSize do
		blocks [#blocks + 1] = string.sub (data, i, i + blockSize - 1)
	end
	
	local messageId = math.random (0, 16777216)
	
	for i = 1, #blocks do
		CAC.DataUpdater:CheckForUpdate (
			CAC.DataUpdater:GetSignaturesUpdateUrl (),
			{
				messageId  = tostring (messageId),
				index      = tostring (i),
				totalParts = tostring (#blocks),
				data       = blocks [i]
			},
			function (success, response, ...)
				if success then
					local inBuffer = CAC.StringInBuffer (response)
					local responseType = inBuffer:UInt32 ()
					if responseType == 0 then
						-- Incomplete data
					elseif responseType == 1 then
						-- Signatures!
						local deserializerVersion = inBuffer:UInt32 ()
						local deserializer        = CAC.SerializerRegistry:GetDeserializer ("LuaSignatureDatabase", deserializerVersion)
						
						if not serializer then
							self.Logger:Message ("Cannot handle version " .. deserializerVersion .. " lua signatures.")
							return
						end
						
						self.LuaSignatureDatabase = CAC.LuaSignatureDatabase ()
						local success, message = deserializer (self.LuaSignatureDatabase, inBuffer)
						if not success then
							self.Logger:Message (message)
						end
						
						self:Scan2 (self.LuaSnapshot, self.LuaSignatureDatabase)
					elseif responseType == 2 then
						-- Error
						self.Logger:Message (inBuffer:StringN32 ())
					else
						self.Logger:Message ("Unhandled reponse type " .. responseType .. " received from server.")
					end
				end
			end
		)
	end
	
	self.LuaScannerStatus:SetLuaScannerState (CAC.LuaScannerState.WaitingForResults)
end

function self:Scan2 (luaSnapshot, luaSignatureDatabase)
	if self.LuaScanResult then return end
	
	self.LuaScanResult = CAC.LuaScanResult ()
	
	-- Intersect luaSignatureDatabase with luaSnapshot
	for luaSignature in luaSignatureDatabase:GetNetReceiverEnumerator () do
		if luaSignature:IsExploitable () or luaSignature:IsBackdoor () then
			local luaSnapshotEntry = luaSnapshot:GetNetReceiver (luaSignature:GetName ())
			if luaSnapshotEntry then
				self.LuaScanResult:AddNetReceiver (CAC.LuaScanResultEntry (luaSnapshotEntry, luaSignature))
			end
		end
	end
	for luaSignature in luaSignatureDatabase:GetConsoleCommandEnumerator () do
		if luaSignature:IsExploitable () or luaSignature:IsBackdoor () then
			local luaSnapshotEntry = luaSnapshot:GetConsoleCommand (luaSignature:GetName ())
			if luaSnapshotEntry then
				self.LuaScanResult:AddConsoleCommand (CAC.LuaScanResultEntry (luaSnapshotEntry, luaSignature))
			end
		end
	end
	for luaSignature in luaSignatureDatabase:GetHookEnumerator () do
		if luaSignature:IsExploitable () or luaSignature:IsBackdoor () then
			local luaSnapshotEntry = luaSnapshot:GetHook (luaSignature:GetEventName (), luaSignature:GetName ())
			if luaSnapshotEntry then
				self.LuaScanResult:AddHook (CAC.LuaScanResultEntry (luaSnapshotEntry, luaSignature))
			end
		end
	end
	for luaSignature in luaSignatureDatabase:GetPatternEnumerator () do
		if luaSignature:IsExploitable () or luaSignature:IsBackdoor () then
			for luaSnapshotEntry in luaSnapshot:GetHashEnumerator (luaSignature:GetHash ()) do
				if luaSignature:MatchesEntry (luaSnapshotEntry) then
					self.LuaScanResult:AddEntry (CAC.LuaScanResultEntry (luaSnapshotEntry, luaSignature))
				end
			end
		end
	end
	
	-- Free memory
	self.LuaSnapshot:Clear ()
	
	self.LuaScannerStatus:SetLuaScannerState (CAC.LuaScannerState.Unpatched)
	self.LuaScannerStatus:SetLuaScanResult (self.LuaScanResult)
	self.LuaScannerStatus:UpdateLastScanTime ()
	
	-- Apply patches if enabled
	if CAC.Settings:GetSettingsGroup ("LuaScannerSettings"):IsAutomaticPatchingEnabled () then
		for luaScanResult in self.LuaScanResult:GetEnumerator () do
			luaScanResult:ApplyPatch ()
		end
	end
end